{
    "sourceFile": "backend/src/controllers/authController.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 29,
            "patches": [
                {
                    "date": 1761149501661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761149538869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,11 +27,12 @@\n     res.status(201).json({\r\n       message: 'User registered successfully',\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: any) {\r\n+  } catch (err: unknown) {\r\n     console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n   }\r\n };\r\n \r\n export const login = async (req: Request, res: Response) => {\r\n@@ -54,9 +55,10 @@\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: any) {\r\n+  } catch (err: unknown) {\r\n     console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n   }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761149615606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import { Request, Response } from 'express';\r\n+import type { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n import User, { IUser } from '../models/User';\r\n import dotenv from 'dotenv';\r\n"
                },
                {
                    "date": 1761149641009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import type { Request, Response } from 'express';\r\n+import { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n import User, { IUser } from '../models/User';\r\n import dotenv from 'dotenv';\r\n@@ -27,12 +27,11 @@\n     res.status(201).json({\r\n       message: 'User registered successfully',\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: unknown) {\r\n+  } catch (err: any) {\r\n     console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n+    res.status(500).json({ message: 'Server error' });\r\n   }\r\n };\r\n \r\n export const login = async (req: Request, res: Response) => {\r\n@@ -55,10 +54,9 @@\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: unknown) {\r\n+  } catch (err: any) {\r\n     console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n+    res.status(500).json({ message: 'Server error' });\r\n\\ No newline at end of file\n   }\r\n-};\n+};\r\n"
                },
                {
                    "date": 1761149646703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+import type { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User, { IUser } from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    // 1) Check if user already exists\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    // 2) Hash password\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+    // 3) Create user\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    // 4) Return safe user data (no password)\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    // 1) Find user\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 2) Compare password\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 3) Create JWT payload & token\r\n+    const payload = { id: user._id, email: user.email, role: user.role };\r\n+    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+    // 4) Return token and user info\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761149687697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n     res.json({\r\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n+    }); \r\n   } catch (err: unknown) {\r\n     console.error(err);\r\n     const message = err instanceof Error ? err.message : 'Server error';\r\n     res.status(500).json({ message });\r\n"
                },
                {
                    "date": 1761150806864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+// import type { Request, Response } from 'express';\r\n+// import bcrypt from 'bcrypt';\r\n+// import jwt from 'jsonwebtoken';\r\n+// import User, { IUser } from '../models/User';\r\n+// import dotenv from 'dotenv';\r\n+// dotenv.config();\r\n+\r\n+// const JWT_SECRET = process.env.JWT_SECRET!;\r\n+// const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+// const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+// export const register = async (req: Request, res: Response) => {\r\n+//   const { name, email, password } = req.body;\r\n+//   try {\r\n+//     // 1) Check if user already exists\r\n+//     const existing = await User.findOne({ email });\r\n+//     if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+//     // 2) Hash password\r\n+//     const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+//     // 3) Create user\r\n+//     const user = new User({ name, email, password: hashed });\r\n+//     await user.save();\r\n+\r\n+//     // 4) Return safe user data (no password)\r\n+//     res.status(201).json({\r\n+//       message: 'User registered successfully',\r\n+//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+//     });\r\n+//   } catch (err: unknown) {\r\n+//     console.error(err);\r\n+//     const message = err instanceof Error ? err.message : 'Server error';\r\n+//     res.status(500).json({ message });\r\n+//   }\r\n+// };\r\n+\r\n+// export const login = async (req: Request, res: Response) => {\r\n+//   const { email, password } = req.body;\r\n+//   try {\r\n+//     // 1) Find user\r\n+//     const user = await User.findOne({ email });\r\n+//     if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+//     // 2) Compare password\r\n+//     const match = await bcrypt.compare(password, user.password);\r\n+//     if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+//     // 3) Create JWT payload & token\r\n+//     const payload = { id: user._id, email: user.email, role: user.role };\r\n+//     const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+//     // 4) Return token and user info\r\n+//     res.json({\r\n+//       message: 'Login successful',\r\n+//       token,\r\n+//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+//     }); \r\n+//   } catch (err: unknown) {\r\n+//     console.error(err);\r\n+//     const message = err instanceof Error ? err.message : 'Server error';\r\n+//     res.status(500).json({ message });\r\n+//   }\r\n+// };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150931079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+import type { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User, { IUser } from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    // 1) Check if user already exists\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    // 2) Hash password\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+    // 3) Create user\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    // 4) Return safe user data (no password)\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    // 1) Find user\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 2) Compare password\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 3) Create JWT payload & token\r\n+    const payload = { id: user._id, email: user.email, role: user.role };\r\n+    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+    // 4) Return token and user info\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    }); \r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150957446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n import type { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n+import User, { IUser } from '../models/User.js';\r\n import dotenv from 'dotenv';\r\n dotenv.config();\r\n \r\n const JWT_SECRET = process.env.JWT_SECRET!;\r\n@@ -60,195 +60,5 @@\n     console.error(err);\r\n     const message = err instanceof Error ? err.message : 'Server error';\r\n     res.status(500).json({ message });\r\n   }\r\n-};\n-// import type { Request, Response } from 'express';\r\n-// import bcrypt from 'bcrypt';\r\n-// import jwt from 'jsonwebtoken';\r\n-// import User, { IUser } from '../models/User';\r\n-// import dotenv from 'dotenv';\r\n-// dotenv.config();\r\n-\r\n-// const JWT_SECRET = process.env.JWT_SECRET!;\r\n-// const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-// const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-// export const register = async (req: Request, res: Response) => {\r\n-//   const { name, email, password } = req.body;\r\n-//   try {\r\n-//     // 1) Check if user already exists\r\n-//     const existing = await User.findOne({ email });\r\n-//     if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-//     // 2) Hash password\r\n-//     const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-//     // 3) Create user\r\n-//     const user = new User({ name, email, password: hashed });\r\n-//     await user.save();\r\n-\r\n-//     // 4) Return safe user data (no password)\r\n-//     res.status(201).json({\r\n-//       message: 'User registered successfully',\r\n-//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-//     });\r\n-//   } catch (err: unknown) {\r\n-//     console.error(err);\r\n-//     const message = err instanceof Error ? err.message : 'Server error';\r\n-//     res.status(500).json({ message });\r\n-//   }\r\n-// };\r\n-\r\n-// export const login = async (req: Request, res: Response) => {\r\n-//   const { email, password } = req.body;\r\n-//   try {\r\n-//     // 1) Find user\r\n-//     const user = await User.findOne({ email });\r\n-//     if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-//     // 2) Compare password\r\n-//     const match = await bcrypt.compare(password, user.password);\r\n-//     if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-//     // 3) Create JWT payload & token\r\n-//     const payload = { id: user._id, email: user.email, role: user.role };\r\n-//     const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-//     // 4) Return token and user info\r\n-//     res.json({\r\n-//       message: 'Login successful',\r\n-//       token,\r\n-//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-//     }); \r\n-//   } catch (err: unknown) {\r\n-//     console.error(err);\r\n-//     const message = err instanceof Error ? err.message : 'Server error';\r\n-//     res.status(500).json({ message });\r\n-//   }\r\n-// };\n-import type { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    }); \r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\n-import { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: any) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: any) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n-  }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150968436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+import { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email }\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Server error' });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });\r\n+\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email }\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Server error' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1761151377660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,51 +1,46 @@\n-import { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n \r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n+// Register\r\n+export const registerUser = async (req: Request, res: Response) => {\r\n   try {\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+    const { name, email, password } = req.body;\r\n \r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n+    const existingUser = await User.findOne({ email });\r\n+    if (existingUser)\r\n+      return res.status(400).json({ message: \"User already exists\" });\r\n \r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email }\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const hashedPassword = await bcrypt.hash(password, 10);\r\n+    const newUser = new User({ name, email, password: hashedPassword });\r\n+    await newUser.save();\r\n+\r\n+    res.status(201).json({ message: \"User registered successfully\" });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n+// Login\r\n+export const loginUser = async (req: Request, res: Response) => {\r\n   try {\r\n+    const { email, password } = req.body;\r\n+\r\n     const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+    if (!user)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n+    if (!isPasswordValid)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });\r\n+    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n \r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email }\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1761152279929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcryptjs\";\r\n+import bcrypt from \"bcrypt\";\r\n import jwt from \"jsonwebtoken\";\r\n import { User } from \"../models/User\";\r\n \r\n const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n@@ -43,68 +43,4 @@\n   } catch (error) {\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n-import type { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User.js';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    }); \r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761390933070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+// src/routes/authRoutes.ts\r\n+import express from \"express\";\r\n+import { registerUser, loginUser } from \"../controllers/authController\";\r\n+\r\n+const router = express.Router();\r\n+\r\n+// Test route (optional)\r\n+router.get(\"/test\", (_req, res) => {\r\n+  res.json({ ok: true, route: \"/api/auth/test\" });\r\n+});\r\n+\r\n+// Register & Login routes (using controllers)\r\n+router.post(\"/register\", registerUser);\r\n+router.post(\"/login\", loginUser);\r\n+\r\n+export default router;\r\n"
                },
                {
                    "date": 1762376236506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,62 +1,79 @@\n-// src/routes/authRoutes.ts\r\n-import express from \"express\";\r\n-import { registerUser, loginUser } from \"../controllers/authController\";\r\n+import { Request, Response } from 'express';\r\n+import User from '../models/User';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import dotenv from 'dotenv';\r\n+import { isValidEmail } from '../utils/validate';\r\n \r\n-const router = express.Router();\r\n \r\n-// Test route (optional)\r\n-router.get(\"/test\", (_req, res) => {\r\n-  res.json({ ok: true, route: \"/api/auth/test\" });\r\n-});\r\n+dotenv.config();\r\n+const JWT_SECRET = process.env.JWT_SECRET || 'secret';\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n \r\n-// Register & Login routes (using controllers)\r\n-router.post(\"/register\", registerUser);\r\n-router.post(\"/login\", loginUser);\r\n \r\n-export default router;\r\n-import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcrypt\";\r\n-import jwt from \"jsonwebtoken\";\r\n-import { User } from \"../models/User\";\r\n+export const signup = async (req: Request, res: Response) => {\r\n+try {\r\n+const { name, email, password } = req.body;\r\n+if (!name || !email || !password) return res.status(400).json({ message: 'All fields required' });\r\n+if (!isValidEmail(email)) return res.status(400).json({ message: 'Invalid email' });\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n \r\n-// Register\r\n-export const registerUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { name, email, password } = req.body;\r\n+const existing = await User.findOne({ email });\r\n+if (existing) return res.status(409).json({ message: 'Email already in use' });\r\n \r\n-    const existingUser = await User.findOne({ email });\r\n-    if (existingUser)\r\n-      return res.status(400).json({ message: \"User already exists\" });\r\n \r\n-    const hashedPassword = await bcrypt.hash(password, 10);\r\n-    const newUser = new User({ name, email, password: hashedPassword });\r\n-    await newUser.save();\r\n+const salt = await bcrypt.genSalt(10);\r\n+const hashed = await bcrypt.hash(password, salt);\r\n \r\n-    res.status(201).json({ message: \"User registered successfully\" });\r\n-  } catch (error) {\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+\r\n+const user = await User.create({ name, email, password: hashed });\r\n+\r\n+\r\n+const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+\r\n+res.status(201).json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n };\r\n \r\n-// Login\r\n-export const loginUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, password } = req.body;\r\n \r\n-    const user = await User.findOne({ email });\r\n-    if (!user)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+export const login = async (req: Request, res: Response) => {\r\n+try {\r\n+const { email, password } = req.body;\r\n+if (!email || !password) return res.status(400).json({ message: 'All fields required' });\r\n \r\n-    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n-    if (!isPasswordValid)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n+const user = await User.findOne({ email });\r\n+if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n \r\n-    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-  } catch (error) {\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+\r\n+const match = await bcrypt.compare(password, user.password);\r\n+if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+\r\n+const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+\r\n+res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n };\r\n+\r\n+\r\n+export const me = async (req: Request, res: Response) => {\r\n+try {\r\n+// @ts-ignore\r\n+const userId = req.userId;\r\n+const user = await User.findById(userId).select('-password');\r\n+if (!user) return res.status(404).json({ message: 'User not found' });\r\n+res.json({ user });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762376244659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,79 +0,0 @@\n-import { Request, Response } from 'express';\r\n-import User from '../models/User';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import dotenv from 'dotenv';\r\n-import { isValidEmail } from '../utils/validate';\r\n-\r\n-\r\n-dotenv.config();\r\n-const JWT_SECRET = process.env.JWT_SECRET || 'secret';\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-\r\n-\r\n-export const signup = async (req: Request, res: Response) => {\r\n-try {\r\n-const { name, email, password } = req.body;\r\n-if (!name || !email || !password) return res.status(400).json({ message: 'All fields required' });\r\n-if (!isValidEmail(email)) return res.status(400).json({ message: 'Invalid email' });\r\n-\r\n-\r\n-const existing = await User.findOne({ email });\r\n-if (existing) return res.status(409).json({ message: 'Email already in use' });\r\n-\r\n-\r\n-const salt = await bcrypt.genSalt(10);\r\n-const hashed = await bcrypt.hash(password, salt);\r\n-\r\n-\r\n-const user = await User.create({ name, email, password: hashed });\r\n-\r\n-\r\n-const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-\r\n-res.status(201).json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\r\n-\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-try {\r\n-const { email, password } = req.body;\r\n-if (!email || !password) return res.status(400).json({ message: 'All fields required' });\r\n-\r\n-\r\n-const user = await User.findOne({ email });\r\n-if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-\r\n-const match = await bcrypt.compare(password, user.password);\r\n-if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-\r\n-const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-\r\n-res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\r\n-\r\n-\r\n-export const me = async (req: Request, res: Response) => {\r\n-try {\r\n-// @ts-ignore\r\n-const userId = req.userId;\r\n-const user = await User.findById(userId).select('-password');\r\n-if (!user) return res.status(404).json({ message: 'User not found' });\r\n-res.json({ user });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762381201832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcrypt\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n+\r\n+// Register\r\n+export const registerUser = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { name, email, password } = req.body;\r\n+\r\n+    const existingUser = await User.findOne({ email });\r\n+    if (existingUser)\r\n+      return res.status(400).json({ message: \"User already exists\" });\r\n+\r\n+    const hashedPassword = await bcrypt.hash(password, 10);\r\n+    const newUser = new User({ name, email, password: hashedPassword });\r\n+    await newUser.save();\r\n+\r\n+    res.status(201).json({ message: \"User registered successfully\" });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// Login\r\n+export const loginUser = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, password } = req.body;\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+\r\n+    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n+    if (!isPasswordValid)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+\r\n+    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n+\r\n+    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1762456786862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,18 +9,31 @@\n export const registerUser = async (req: Request, res: Response) => {\r\n   try {\r\n     const { name, email, password } = req.body;\r\n \r\n+    if (!name || !email || !password) {\r\n+      return res.status(400).json({ message: \"All fields are required\" });\r\n+    }\r\n+\r\n     const existingUser = await User.findOne({ email });\r\n-    if (existingUser)\r\n+    if (existingUser) {\r\n       return res.status(400).json({ message: \"User already exists\" });\r\n+    }\r\n \r\n     const hashedPassword = await bcrypt.hash(password, 10);\r\n     const newUser = new User({ name, email, password: hashedPassword });\r\n     await newUser.save();\r\n \r\n-    res.status(201).json({ message: \"User registered successfully\" });\r\n+    const token = jwt.sign({ id: newUser._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n+\r\n+    // ✅ Send user info back\r\n+    res.status(201).json({\r\n+      message: \"User registered successfully\",\r\n+      token,\r\n+      user: { id: newUser._id, name: newUser.name, email: newUser.email },\r\n+    });\r\n   } catch (error) {\r\n+    console.error(\"Register error:\", error);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n"
                },
                {
                    "date": 1763651948093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,59 +1,35 @@\n import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcrypt\";\r\n-import jwt from \"jsonwebtoken\";\r\n+import bcrypt from \"bcryptjs\";\r\n import { User } from \"../models/User\";\r\n+import { generateToken } from \"../utils/generateToken\";\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n \r\n-// Register\r\n-export const registerUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { name, email, password } = req.body;\r\n+  const exists = await User.findOne({ email });\r\n+  if (exists) return res.status(400).json({ message: \"Email already exists\" });\r\n \r\n-    if (!name || !email || !password) {\r\n-      return res.status(400).json({ message: \"All fields are required\" });\r\n-    }\r\n+  const hashed = await bcrypt.hash(password, 10);\r\n \r\n-    const existingUser = await User.findOne({ email });\r\n-    if (existingUser) {\r\n-      return res.status(400).json({ message: \"User already exists\" });\r\n-    }\r\n+  const user = await User.create({ name, email, password: hashed });\r\n \r\n-    const hashedPassword = await bcrypt.hash(password, 10);\r\n-    const newUser = new User({ name, email, password: hashedPassword });\r\n-    await newUser.save();\r\n-\r\n-    const token = jwt.sign({ id: newUser._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n-\r\n-    // ✅ Send user info back\r\n-    res.status(201).json({\r\n-      message: \"User registered successfully\",\r\n-      token,\r\n-      user: { id: newUser._id, name: newUser.name, email: newUser.email },\r\n-    });\r\n-  } catch (error) {\r\n-    console.error(\"Register error:\", error);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+  res.json({\r\n+    user,\r\n+    token: generateToken(user._id.toString()),\r\n+  });\r\n };\r\n \r\n-// Login\r\n-export const loginUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, password } = req.body;\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n \r\n-    const user = await User.findOne({ email });\r\n-    if (!user)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+  const user = await User.findOne({ email });\r\n+  if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n-    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n-    if (!isPasswordValid)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+  const match = await bcrypt.compare(password, user.password);\r\n+  if (!match) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n-    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n-\r\n-    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-  } catch (error) {\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+  res.json({\r\n+    user,\r\n+    token: generateToken(user._id.toString())\r\n+  });\r\n };\r\n"
                },
                {
                    "date": 1763652666774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,35 +1,53 @@\n import { Request, Response } from \"express\";\r\n import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n import { User } from \"../models/User\";\r\n-import { generateToken } from \"../utils/generateToken\";\r\n \r\n+const signToken = (id: string, email: string) => {\r\n+  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n+};\r\n+\r\n export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n+  try {\r\n+    const { name, email, password } = req.body;\r\n \r\n-  const exists = await User.findOne({ email });\r\n-  if (exists) return res.status(400).json({ message: \"Email already exists\" });\r\n+    const exists = await User.findOne({ email });\r\n+    if (exists) {\r\n+      return res.status(400).json({ message: \"Email already registered\" });\r\n+    }\r\n \r\n-  const hashed = await bcrypt.hash(password, 10);\r\n+    const hashed = await bcrypt.hash(password, 10);\r\n \r\n-  const user = await User.create({ name, email, password: hashed });\r\n+    const user = await User.create({\r\n+      name,\r\n+      email,\r\n+      password: hashed,\r\n+    });\r\n \r\n-  res.json({\r\n-    user,\r\n-    token: generateToken(user._id.toString()),\r\n-  });\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Register error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n };\r\n \r\n export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n+  try {\r\n+    const { email, password } = req.body;\r\n \r\n-  const user = await User.findOne({ email });\r\n-  if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n-  const match = await bcrypt.compare(password, user.password);\r\n-  if (!match) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    const isMatch = await bcrypt.compare(password, user.password);\r\n+    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n-  res.json({\r\n-    user,\r\n-    token: generateToken(user._id.toString())\r\n-  });\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Login error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n };\r\n"
                },
                {
                    "date": 1763991170708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,140 @@\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n+import { sendEmail } from \"../utils/sendEmail\";\r\n+\r\n+const signToken = (id: string, email: string) => {\r\n+  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n+};\r\n+\r\n+const generateOtp = () => {\r\n+  return Math.floor(100000 + Math.random() * 900000).toString(); // 6 digits\r\n+};\r\n+\r\n+// --------------------\r\n+// REGISTER (same)\r\n+// --------------------\r\n+export const register = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { name, email, password } = req.body;\r\n+\r\n+    const exists = await User.findOne({ email });\r\n+    if (exists) {\r\n+      return res.status(400).json({ message: \"Email already registered\" });\r\n+    }\r\n+\r\n+    const hashed = await bcrypt.hash(password, 10);\r\n+\r\n+    const user = await User.create({\r\n+      name,\r\n+      email,\r\n+      password: hashed,\r\n+    });\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Register error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// PASSWORD LOGIN (same)\r\n+// --------------------\r\n+export const login = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, password } = req.body;\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+\r\n+    const isMatch = await bcrypt.compare(password, user.password);\r\n+    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Login error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// SEND OTP (NEW)\r\n+// --------------------\r\n+export const sendOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email } = req.body;\r\n+    if (!email) return res.status(400).json({ message: \"Email is required\" });\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(404).json({ message: \"No account found for this email\" });\r\n+\r\n+    const otp = generateOtp();\r\n+    const otpHash = await bcrypt.hash(otp, 10);\r\n+\r\n+    user.otpHash = otpHash;\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n+    await user.save();\r\n+\r\n+    await sendEmail({\r\n+      to: user.email,\r\n+      subject: \"Your CarFinderHub Login Code\",\r\n+      html: `\r\n+        <div style=\"font-family: Arial; line-height:1.6\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Use this code to login. It expires in 10 minutes:</p>\r\n+          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n+          <p>If you didn't request this, ignore this email.</p>\r\n+        </div>\r\n+      `,\r\n+    });\r\n+\r\n+    res.json({ message: \"OTP sent to your email\" });\r\n+  } catch (err) {\r\n+    console.error(\"Send OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// VERIFY OTP (NEW)\r\n+// --------------------\r\n+export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, otp } = req.body;\r\n+    if (!email || !otp) {\r\n+      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n+    }\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n+      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n+    }\r\n+\r\n+    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n+      user.otpHash = null;\r\n+      user.otpExpiresAt = null;\r\n+      await user.save();\r\n+      return res.status(400).json({ message: \"OTP expired\" });\r\n+    }\r\n+\r\n+    const ok = await bcrypt.compare(otp, user.otpHash);\r\n+    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n+\r\n+    // clear OTP after successful login\r\n+    user.otpHash = null;\r\n+    user.otpExpiresAt = null;\r\n+    await user.save();\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Verify OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1763991522329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,142 @@\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n+import { sendEmail } from \"../utils/sendEmail\";\r\n+\r\n+const signToken = (id: string, email: string) => {\r\n+  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n+};\r\n+\r\n+const generateOtp = () => {\r\n+  return Math.floor(100000 + Math.random() * 900000).toString(); // 6 digits\r\n+};\r\n+\r\n+// --------------------\r\n+// REGISTER (same)\r\n+// --------------------\r\n+export const register = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { name, email, password } = req.body;\r\n+\r\n+    const exists = await User.findOne({ email });\r\n+    if (exists) {\r\n+      return res.status(400).json({ message: \"Email already registered\" });\r\n+    }\r\n+\r\n+    const hashed = await bcrypt.hash(password, 10);\r\n+\r\n+    const user = await User.create({\r\n+      name,\r\n+      email,\r\n+      password: hashed,\r\n+    });\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Register error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// PASSWORD LOGIN (same)\r\n+// --------------------\r\n+export const login = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, password } = req.body;\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+\r\n+    const isMatch = await bcrypt.compare(password, user.password);\r\n+    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Login error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// SEND OTP (NEW)\r\n+// --------------------\r\n+export const sendOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email } = req.body;\r\n+    if (!email) return res.status(400).json({ message: \"Email is required\" });\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(404).json({ message: \"No account found for this email\" });\r\n+\r\n+    const otp = generateOtp();\r\n+    const otpHash = await bcrypt.hash(otp, 10);\r\n+\r\n+    user.otpHash = otpHash;\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n+    await user.save();\r\n+\r\n+    await sendEmail({\r\n+      to: user.email,\r\n+      subject: \"Your CarFinderHub Login Code\",\r\n+      html: `\r\n+        <div style=\"font-family: Arial; line-height:1.6\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Use this code to login. It expires in 10 minutes:</p>\r\n+          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n+          <p>If you didn't request this, ignore this email.</p>\r\n+        </div>\r\n+      `,\r\n+    });\r\n+\r\n+    res.json({ message: \"OTP sent to your email\" });\r\n+  } catch (err) {\r\n+    console.error(\"Send OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// --------------------\r\n+// VERIFY OTP (NEW)\r\n+// --------------------\r\n+export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, otp } = req.body;\r\n+    if (!email || !otp) {\r\n+      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n+    }\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n+      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n+    }\r\n+\r\n+    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n+      user.otpHash = null;\r\n+      user.otpExpiresAt = null;\r\n+      await user.save();\r\n+      return res.status(400).json({ message: \"OTP expired\" });\r\n+    }\r\n+\r\n+    const ok = await bcrypt.compare(otp, user.otpHash);\r\n+    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n+\r\n+    // clear OTP after successful login\r\n+    user.otpHash = null;\r\n+    user.otpExpiresAt = null;\r\n+    await user.save();\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+    res.json({ user, token });\r\n+\r\n+  } catch (err) {\r\n+    console.error(\"Verify OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n"
                },
                {
                    "date": 1763991770777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -111,30 +111,39 @@\n       return res.status(400).json({ message: \"Email and OTP are required\" });\r\n     }\r\n \r\n     const user = await User.findOne({ email });\r\n-    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n+    if (!user) {\r\n       return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n     }\r\n \r\n-    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n+    // TypeScript safe checks (no more errors)\r\n+    const otpHash = user.otpHash as string | null;\r\n+    const otpExpiresAt = user.otpExpiresAt as Date | null;\r\n+\r\n+    if (!otpHash || !otpExpiresAt) {\r\n+      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n+    }\r\n+\r\n+    if (otpExpiresAt.getTime() < Date.now()) {\r\n       user.otpHash = null;\r\n       user.otpExpiresAt = null;\r\n       await user.save();\r\n       return res.status(400).json({ message: \"OTP expired\" });\r\n     }\r\n \r\n-    const ok = await bcrypt.compare(otp, user.otpHash);\r\n-    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n+    const ok = await bcrypt.compare(otp, otpHash);\r\n+    if (!ok) {\r\n+      return res.status(400).json({ message: \"Invalid OTP\" });\r\n+    }\r\n \r\n-    // clear OTP after successful login\r\n+    // Clear OTP after success\r\n     user.otpHash = null;\r\n     user.otpExpiresAt = null;\r\n     await user.save();\r\n \r\n     const token = signToken(user._id.toString(), user.email);\r\n     res.json({ user, token });\r\n-\r\n   } catch (err) {\r\n     console.error(\"Verify OTP error:\", err);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n"
                },
                {
                    "date": 1763992623630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,20 +80,9 @@\n     user.otpHash = otpHash;\r\n     user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n     await user.save();\r\n \r\n-    await sendEmail({\r\n-      to: user.email,\r\n-      subject: \"Your CarFinderHub Login Code\",\r\n-      html: `\r\n-        <div style=\"font-family: Arial; line-height:1.6\">\r\n-          <h2>Your OTP Code</h2>\r\n-          <p>Use this code to login. It expires in 10 minutes:</p>\r\n-          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n-          <p>If you didn't request this, ignore this email.</p>\r\n-        </div>\r\n-      `,\r\n-    });\r\n+   v\r\n \r\n     res.json({ message: \"OTP sent to your email\" });\r\n   } catch (err) {\r\n     console.error(\"Send OTP error:\", err);\r\n"
                },
                {
                    "date": 1763992744274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,20 @@\n     user.otpHash = otpHash;\r\n     user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n     await user.save();\r\n \r\n-   v\r\n+    await sendEmail({\r\n+      to: user.email,\r\n+      subject: \"Your CarFinderHub Login Code\",\r\n+      html: `\r\n+        <div style=\"font-family: Arial; line-height:1.6\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Use this code to login. It expires in 10 minutes:</p>\r\n+          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n+          <p>If you didn't request this, ignore this email.</p>\r\n+        </div>\r\n+      `,\r\n+    });\r\n \r\n     res.json({ message: \"OTP sent to your email\" });\r\n   } catch (err) {\r\n     console.error(\"Send OTP error:\", err);\r\n@@ -137,197 +148,4 @@\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n-import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcryptjs\";\r\n-import jwt from \"jsonwebtoken\";\r\n-import { User } from \"../models/User\";\r\n-import { sendEmail } from \"../utils/sendEmail\";\r\n-\r\n-const signToken = (id: string, email: string) => {\r\n-  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n-};\r\n-\r\n-const generateOtp = () => {\r\n-  return Math.floor(100000 + Math.random() * 900000).toString(); // 6 digits\r\n-};\r\n-\r\n-// --------------------\r\n-// REGISTER (same)\r\n-// --------------------\r\n-export const register = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { name, email, password } = req.body;\r\n-\r\n-    const exists = await User.findOne({ email });\r\n-    if (exists) {\r\n-      return res.status(400).json({ message: \"Email already registered\" });\r\n-    }\r\n-\r\n-    const hashed = await bcrypt.hash(password, 10);\r\n-\r\n-    const user = await User.create({\r\n-      name,\r\n-      email,\r\n-      password: hashed,\r\n-    });\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Register error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n-// --------------------\r\n-// PASSWORD LOGIN (same)\r\n-// --------------------\r\n-export const login = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, password } = req.body;\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n-\r\n-    const isMatch = await bcrypt.compare(password, user.password);\r\n-    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Login error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n-// --------------------\r\n-// SEND OTP (NEW)\r\n-// --------------------\r\n-export const sendOtpLogin = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email } = req.body;\r\n-    if (!email) return res.status(400).json({ message: \"Email is required\" });\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(404).json({ message: \"No account found for this email\" });\r\n-\r\n-    const otp = generateOtp();\r\n-    const otpHash = await bcrypt.hash(otp, 10);\r\n-\r\n-    user.otpHash = otpHash;\r\n-    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n-    await user.save();\r\n-\r\n-    await sendEmail({\r\n-      to: user.email,\r\n-      subject: \"Your CarFinderHub Login Code\",\r\n-      html: `\r\n-        <div style=\"font-family: Arial; line-height:1.6\">\r\n-          <h2>Your OTP Code</h2>\r\n-          <p>Use this code to login. It expires in 10 minutes:</p>\r\n-          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n-          <p>If you didn't request this, ignore this email.</p>\r\n-        </div>\r\n-      `,\r\n-    });\r\n-\r\n-    res.json({ message: \"OTP sent to your email\" });\r\n-  } catch (err) {\r\n-    console.error(\"Send OTP error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n-// --------------------\r\n-// VERIFY OTP (NEW)\r\n-// --------------------\r\n-export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, otp } = req.body;\r\n-    if (!email || !otp) {\r\n-      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n-    }\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n-      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n-    }\r\n-\r\n-    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n-      user.otpHash = null;\r\n-      user.otpExpiresAt = null;\r\n-      await user.save();\r\n-      return res.status(400).json({ message: \"OTP expired\" });\r\n-    }\r\n-\r\n-    const ok = await bcrypt.compare(otp, user.otpHash);\r\n-    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n-\r\n-    // clear OTP after successful login\r\n-    user.otpHash = null;\r\n-    user.otpExpiresAt = null;\r\n-    await user.save();\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Verify OTP error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcryptjs\";\r\n-import jwt from \"jsonwebtoken\";\r\n-import { User } from \"../models/User\";\r\n-\r\n-const signToken = (id: string, email: string) => {\r\n-  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n-};\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { name, email, password } = req.body;\r\n-\r\n-    const exists = await User.findOne({ email });\r\n-    if (exists) {\r\n-      return res.status(400).json({ message: \"Email already registered\" });\r\n-    }\r\n-\r\n-    const hashed = await bcrypt.hash(password, 10);\r\n-\r\n-    const user = await User.create({\r\n-      name,\r\n-      email,\r\n-      password: hashed,\r\n-    });\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Register error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, password } = req.body;\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n-\r\n-    const isMatch = await bcrypt.compare(password, user.password);\r\n-    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Login error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n"
                },
                {
                    "date": 1763992750223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,13 @@\n import { Request, Response } from \"express\";\r\n import bcrypt from \"bcryptjs\";\r\n import jwt from \"jsonwebtoken\";\r\n import { User } from \"../models/User\";\r\n-import { sendEmail } from \"../utils/sendEmail\";\r\n \r\n const signToken = (id: string, email: string) => {\r\n   return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n };\r\n \r\n-const generateOtp = () => {\r\n-  return Math.floor(100000 + Math.random() * 900000).toString(); // 6 digits\r\n-};\r\n-\r\n-// --------------------\r\n-// REGISTER (same)\r\n-// --------------------\r\n export const register = async (req: Request, res: Response) => {\r\n   try {\r\n     const { name, email, password } = req.body;\r\n \r\n@@ -40,11 +32,8 @@\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n-// --------------------\r\n-// PASSWORD LOGIN (same)\r\n-// --------------------\r\n export const login = async (req: Request, res: Response) => {\r\n   try {\r\n     const { email, password } = req.body;\r\n \r\n@@ -61,91 +50,4 @@\n     console.error(\"Login error:\", err);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n-\r\n-// --------------------\r\n-// SEND OTP (NEW)\r\n-// --------------------\r\n-export const sendOtpLogin = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email } = req.body;\r\n-    if (!email) return res.status(400).json({ message: \"Email is required\" });\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(404).json({ message: \"No account found for this email\" });\r\n-\r\n-    const otp = generateOtp();\r\n-    const otpHash = await bcrypt.hash(otp, 10);\r\n-\r\n-    user.otpHash = otpHash;\r\n-    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 min\r\n-    await user.save();\r\n-\r\n-    await sendEmail({\r\n-      to: user.email,\r\n-      subject: \"Your CarFinderHub Login Code\",\r\n-      html: `\r\n-        <div style=\"font-family: Arial; line-height:1.6\">\r\n-          <h2>Your OTP Code</h2>\r\n-          <p>Use this code to login. It expires in 10 minutes:</p>\r\n-          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n-          <p>If you didn't request this, ignore this email.</p>\r\n-        </div>\r\n-      `,\r\n-    });\r\n-\r\n-    res.json({ message: \"OTP sent to your email\" });\r\n-  } catch (err) {\r\n-    console.error(\"Send OTP error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n-// --------------------\r\n-// VERIFY OTP (NEW)\r\n-// --------------------\r\n-export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, otp } = req.body;\r\n-    if (!email || !otp) {\r\n-      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n-    }\r\n-\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) {\r\n-      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n-    }\r\n-\r\n-    // TypeScript safe checks (no more errors)\r\n-    const otpHash = user.otpHash as string | null;\r\n-    const otpExpiresAt = user.otpExpiresAt as Date | null;\r\n-\r\n-    if (!otpHash || !otpExpiresAt) {\r\n-      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n-    }\r\n-\r\n-    if (otpExpiresAt.getTime() < Date.now()) {\r\n-      user.otpHash = null;\r\n-      user.otpExpiresAt = null;\r\n-      await user.save();\r\n-      return res.status(400).json({ message: \"OTP expired\" });\r\n-    }\r\n-\r\n-    const ok = await bcrypt.compare(otp, otpHash);\r\n-    if (!ok) {\r\n-      return res.status(400).json({ message: \"Invalid OTP\" });\r\n-    }\r\n-\r\n-    // Clear OTP after success\r\n-    user.otpHash = null;\r\n-    user.otpExpiresAt = null;\r\n-    await user.save();\r\n-\r\n-    const token = signToken(user._id.toString(), user.email);\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Verify OTP error:\", err);\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n-};\r\n-\r\n"
                },
                {
                    "date": 1763993986590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,28 @@\n import { Request, Response } from \"express\";\r\n import bcrypt from \"bcryptjs\";\r\n import jwt from \"jsonwebtoken\";\r\n import { User } from \"../models/User\";\r\n+import { sendEmail } from \"../utils/sendEmail\";\r\n \r\n const signToken = (id: string, email: string) => {\r\n   return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n };\r\n \r\n+const generateOtp = () => {\r\n+  // 6-digit OTP\r\n+  return Math.floor(100000 + Math.random() * 900000).toString();\r\n+};\r\n+\r\n+// ---------------------------\r\n+// REGISTER (same as before)\r\n+// ---------------------------\r\n export const register = async (req: Request, res: Response) => {\r\n   try {\r\n     const { name, email, password } = req.body;\r\n \r\n     const exists = await User.findOne({ email });\r\n-    if (exists) {\r\n-      return res.status(400).json({ message: \"Email already registered\" });\r\n-    }\r\n+    if (exists) return res.status(400).json({ message: \"Email already registered\" });\r\n \r\n     const hashed = await bcrypt.hash(password, 10);\r\n \r\n     const user = await User.create({\r\n@@ -24,30 +31,95 @@\n       password: hashed,\r\n     });\r\n \r\n     const token = signToken(user._id.toString(), user.email);\r\n-\r\n     res.json({ user, token });\r\n   } catch (err) {\r\n     console.error(\"Register error:\", err);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n+// ---------------------------------------------------\r\n+// STEP 1 LOGIN: verify password, then SEND OTP\r\n+// ---------------------------------------------------\r\n export const login = async (req: Request, res: Response) => {\r\n   try {\r\n     const { email, password } = req.body;\r\n \r\n+    if (!email || !password) {\r\n+      return res.status(400).json({ message: \"Email and password are required\" });\r\n+    }\r\n+\r\n     const user = await User.findOne({ email });\r\n     if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n     const isMatch = await bcrypt.compare(password, user.password);\r\n     if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n \r\n-    const token = signToken(user._id.toString(), user.email);\r\n+    // generate + hash otp\r\n+    const otp = generateOtp();\r\n+    const otpHash = await bcrypt.hash(otp, 10);\r\n \r\n-    res.json({ user, token });\r\n+    user.otpHash = otpHash;\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 mins\r\n+    await user.save();\r\n+\r\n+    await sendEmail(\r\n+      user.email,\r\n+      \"Your CarFinderHub Login Code\",\r\n+      `\r\n+        <div style=\"font-family:Arial;line-height:1.6\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Use this code to login. It expires in 10 minutes:</p>\r\n+          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n+          <p>If you didn't request this, ignore the email.</p>\r\n+        </div>\r\n+      `\r\n+    );\r\n+\r\n+    return res.json({ message: \"OTP sent to your email\" });\r\n   } catch (err) {\r\n-    console.error(\"Login error:\", err);\r\n+    console.error(\"Login(send OTP) error:\", err);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n+\r\n+// ---------------------------------------------------\r\n+// STEP 2 LOGIN: verify OTP, return token\r\n+// ---------------------------------------------------\r\n+export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, otp } = req.body;\r\n+\r\n+    if (!email || !otp) {\r\n+      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n+    }\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n+      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n+    }\r\n+\r\n+    // expired?\r\n+    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n+      user.otpHash = null;\r\n+      user.otpExpiresAt = null;\r\n+      await user.save();\r\n+      return res.status(400).json({ message: \"OTP expired\" });\r\n+    }\r\n+\r\n+    const ok = await bcrypt.compare(otp, user.otpHash);\r\n+    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n+\r\n+    // clear otp after success\r\n+    user.otpHash = null;\r\n+    user.otpExpiresAt = null;\r\n+    await user.save();\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+    return res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Verify OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1764774677585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,19 +50,25 @@\n       return res.status(400).json({ message: \"Email and password are required\" });\r\n     }\r\n \r\n     const user = await User.findOne({ email });\r\n-    if (!user) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    if (!user) {\r\n+      return res.status(404).json({\r\n+        message: \"User not found. Please register first.\",\r\n+      });\r\n+    }\r\n \r\n     const isMatch = await bcrypt.compare(password, user.password);\r\n-    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    if (!isMatch) {\r\n+      return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    }\r\n \r\n-    // generate + hash otp\r\n+    // generate OTP\r\n     const otp = generateOtp();\r\n     const otpHash = await bcrypt.hash(otp, 10);\r\n \r\n     user.otpHash = otpHash;\r\n-    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 mins\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);\r\n     await user.save();\r\n \r\n     await sendEmail(\r\n       user.email,\r\n"
                },
                {
                    "date": 1764774710871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,22 +92,27 @@\n \r\n // ---------------------------------------------------\r\n // STEP 2 LOGIN: verify OTP, return token\r\n // ---------------------------------------------------\r\n-export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+eexport const verifyOtpLogin = async (req: Request, res: Response) => {\r\n   try {\r\n     const { email, otp } = req.body;\r\n \r\n     if (!email || !otp) {\r\n       return res.status(400).json({ message: \"Email and OTP are required\" });\r\n     }\r\n \r\n     const user = await User.findOne({ email });\r\n-    if (!user || !user.otpHash || !user.otpExpiresAt) {\r\n+    if (!user) {\r\n+      return res.status(404).json({\r\n+        message: \"User not found. Please register first.\",\r\n+      });\r\n+    }\r\n+\r\n+    if (!user.otpHash || !user.otpExpiresAt) {\r\n       return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n     }\r\n \r\n-    // expired?\r\n     if (user.otpExpiresAt.getTime() < Date.now()) {\r\n       user.otpHash = null;\r\n       user.otpExpiresAt = null;\r\n       await user.save();\r\n@@ -116,9 +121,8 @@\n \r\n     const ok = await bcrypt.compare(otp, user.otpHash);\r\n     if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n \r\n-    // clear otp after success\r\n     user.otpHash = null;\r\n     user.otpExpiresAt = null;\r\n     await user.save();\r\n \r\n"
                },
                {
                    "date": 1764774716687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,135 @@\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n+import { sendEmail } from \"../utils/sendEmail\";\r\n+\r\n+const signToken = (id: string, email: string) => {\r\n+  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n+};\r\n+\r\n+const generateOtp = () => {\r\n+  // 6-digit OTP\r\n+  return Math.floor(100000 + Math.random() * 900000).toString();\r\n+};\r\n+\r\n+// ---------------------------\r\n+// REGISTER (same as before)\r\n+// ---------------------------\r\n+export const register = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { name, email, password } = req.body;\r\n+\r\n+    const exists = await User.findOne({ email });\r\n+    if (exists) return res.status(400).json({ message: \"Email already registered\" });\r\n+\r\n+    const hashed = await bcrypt.hash(password, 10);\r\n+\r\n+    const user = await User.create({\r\n+      name,\r\n+      email,\r\n+      password: hashed,\r\n+    });\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+    res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Register error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// ---------------------------------------------------\r\n+// STEP 1 LOGIN: verify password, then SEND OTP\r\n+// ---------------------------------------------------\r\n+export const login = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, password } = req.body;\r\n+\r\n+    if (!email || !password) {\r\n+      return res.status(400).json({ message: \"Email and password are required\" });\r\n+    }\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) {\r\n+      return res.status(404).json({\r\n+        message: \"User not found. Please register first.\",\r\n+      });\r\n+    }\r\n+\r\n+    const isMatch = await bcrypt.compare(password, user.password);\r\n+    if (!isMatch) {\r\n+      return res.status(400).json({ message: \"Invalid credentials\" });\r\n+    }\r\n+\r\n+    // generate OTP\r\n+    const otp = generateOtp();\r\n+    const otpHash = await bcrypt.hash(otp, 10);\r\n+\r\n+    user.otpHash = otpHash;\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);\r\n+    await user.save();\r\n+\r\n+    await sendEmail(\r\n+      user.email,\r\n+      \"Your CarFinderHub Login Code\",\r\n+      `\r\n+        <div style=\"font-family:Arial;line-height:1.6\">\r\n+          <h2>Your OTP Code</h2>\r\n+          <p>Use this code to login. It expires in 10 minutes:</p>\r\n+          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n+          <p>If you didn't request this, ignore the email.</p>\r\n+        </div>\r\n+      `\r\n+    );\r\n+\r\n+    return res.json({ message: \"OTP sent to your email\" });\r\n+  } catch (err) {\r\n+    console.error(\"Login(send OTP) error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n+\r\n+// ---------------------------------------------------\r\n+// STEP 2 LOGIN: verify OTP, return token\r\n+// ---------------------------------------------------\r\n+export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+  try {\r\n+    const { email, otp } = req.body;\r\n+\r\n+    if (!email || !otp) {\r\n+      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n+    }\r\n+\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) {\r\n+      return res.status(404).json({\r\n+        message: \"User not found. Please register first.\",\r\n+      });\r\n+    }\r\n+\r\n+    if (!user.otpHash || !user.otpExpiresAt) {\r\n+      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n+    }\r\n+\r\n+    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n+      user.otpHash = null;\r\n+      user.otpExpiresAt = null;\r\n+      await user.save();\r\n+      return res.status(400).json({ message: \"OTP expired\" });\r\n+    }\r\n+\r\n+    const ok = await bcrypt.compare(otp, user.otpHash);\r\n+    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n+\r\n+    user.otpHash = null;\r\n+    user.otpExpiresAt = null;\r\n+    await user.save();\r\n+\r\n+    const token = signToken(user._id.toString(), user.email);\r\n+    return res.json({ user, token });\r\n+  } catch (err) {\r\n+    console.error(\"Verify OTP error:\", err);\r\n+    res.status(500).json({ message: \"Server error\" });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1764775561542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,14 +8,13 @@\n   return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n };\r\n \r\n const generateOtp = () => {\r\n-  // 6-digit OTP\r\n   return Math.floor(100000 + Math.random() * 900000).toString();\r\n };\r\n \r\n // ---------------------------\r\n-// REGISTER (same as before)\r\n+// REGISTER\r\n // ---------------------------\r\n export const register = async (req: Request, res: Response) => {\r\n   try {\r\n     const { name, email, password } = req.body;\r\n@@ -39,9 +38,9 @@\n   }\r\n };\r\n \r\n // ---------------------------------------------------\r\n-// STEP 1 LOGIN: verify password, then SEND OTP\r\n+// STEP 1 LOGIN → SEND OTP\r\n // ---------------------------------------------------\r\n export const login = async (req: Request, res: Response) => {\r\n   try {\r\n     const { email, password } = req.body;\r\n@@ -61,9 +60,8 @@\n     if (!isMatch) {\r\n       return res.status(400).json({ message: \"Invalid credentials\" });\r\n     }\r\n \r\n-    // generate OTP\r\n     const otp = generateOtp();\r\n     const otpHash = await bcrypt.hash(otp, 10);\r\n \r\n     user.otpHash = otpHash;\r\n@@ -90,9 +88,9 @@\n   }\r\n };\r\n \r\n // ---------------------------------------------------\r\n-// STEP 2 LOGIN: verify OTP, return token\r\n+// STEP 2 LOGIN → VERIFY OTP\r\n // ---------------------------------------------------\r\n export const verifyOtpLogin = async (req: Request, res: Response) => {\r\n   try {\r\n     const { email, otp } = req.body;\r\n@@ -132,139 +130,77 @@\n     console.error(\"Verify OTP error:\", err);\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n-import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcryptjs\";\r\n-import jwt from \"jsonwebtoken\";\r\n-import { User } from \"../models/User\";\r\n-import { sendEmail } from \"../utils/sendEmail\";\r\n \r\n-const signToken = (id: string, email: string) => {\r\n-  return jwt.sign({ id, email }, process.env.JWT_SECRET!, { expiresIn: \"30d\" });\r\n-};\r\n-\r\n-const generateOtp = () => {\r\n-  // 6-digit OTP\r\n-  return Math.floor(100000 + Math.random() * 900000).toString();\r\n-};\r\n-\r\n-// ---------------------------\r\n-// REGISTER (same as before)\r\n-// ---------------------------\r\n-export const register = async (req: Request, res: Response) => {\r\n+// ---------------------------------------------------\r\n+// FORGOT PASSWORD → SEND OTP\r\n+// ---------------------------------------------------\r\n+export const forgotPassword = async (req: Request, res: Response) => {\r\n   try {\r\n-    const { name, email, password } = req.body;\r\n+    const { email } = req.body;\r\n+    if (!email) return res.status(400).json({ message: \"Email required\" });\r\n \r\n-    const exists = await User.findOne({ email });\r\n-    if (exists) return res.status(400).json({ message: \"Email already registered\" });\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(404).json({ message: \"No account found with this email\" });\r\n \r\n-    const hashed = await bcrypt.hash(password, 10);\r\n+    const otp = generateOtp();\r\n+    user.otpHash = await bcrypt.hash(otp, 10);\r\n+    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);\r\n+    await user.save();\r\n \r\n-    const user = await User.create({\r\n-      name,\r\n+    await sendEmail(\r\n       email,\r\n-      password: hashed,\r\n-    });\r\n+      \"Password Reset Code\",\r\n+      `<h1>Your OTP: ${otp}</h1><p>Valid for 10 minutes.</p>`\r\n+    );\r\n \r\n-    const token = signToken(user._id.toString(), user.email);\r\n-    res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Register error:\", err);\r\n+    res.json({ message: \"OTP sent to your email\" });\r\n+  } catch {\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n // ---------------------------------------------------\r\n-// STEP 1 LOGIN: verify password, then SEND OTP\r\n+// FORGOT PASSWORD → VERIFY OTP\r\n // ---------------------------------------------------\r\n-export const login = async (req: Request, res: Response) => {\r\n+export const verifyForgotOtp = async (req: Request, res: Response) => {\r\n   try {\r\n-    const { email, password } = req.body;\r\n+    const { email, otp } = req.body;\r\n \r\n-    if (!email || !password) {\r\n-      return res.status(400).json({ message: \"Email and password are required\" });\r\n-    }\r\n-\r\n     const user = await User.findOne({ email });\r\n-    if (!user) {\r\n-      return res.status(404).json({\r\n-        message: \"User not found. Please register first.\",\r\n-      });\r\n-    }\r\n+    if (!user) return res.status(404).json({ message: \"User not found\" });\r\n \r\n-    const isMatch = await bcrypt.compare(password, user.password);\r\n-    if (!isMatch) {\r\n-      return res.status(400).json({ message: \"Invalid credentials\" });\r\n-    }\r\n+    if (!user.otpHash) return res.status(400).json({ message: \"OTP not requested\" });\r\n \r\n-    // generate OTP\r\n-    const otp = generateOtp();\r\n-    const otpHash = await bcrypt.hash(otp, 10);\r\n+    const ok = await bcrypt.compare(otp, user.otpHash);\r\n+    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n \r\n-    user.otpHash = otpHash;\r\n-    user.otpExpiresAt = new Date(Date.now() + 10 * 60 * 1000);\r\n-    await user.save();\r\n-\r\n-    await sendEmail(\r\n-      user.email,\r\n-      \"Your CarFinderHub Login Code\",\r\n-      `\r\n-        <div style=\"font-family:Arial;line-height:1.6\">\r\n-          <h2>Your OTP Code</h2>\r\n-          <p>Use this code to login. It expires in 10 minutes:</p>\r\n-          <h1 style=\"letter-spacing:4px;\">${otp}</h1>\r\n-          <p>If you didn't request this, ignore the email.</p>\r\n-        </div>\r\n-      `\r\n-    );\r\n-\r\n-    return res.json({ message: \"OTP sent to your email\" });\r\n-  } catch (err) {\r\n-    console.error(\"Login(send OTP) error:\", err);\r\n+    res.json({ message: \"OTP verified\" });\r\n+  } catch {\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n // ---------------------------------------------------\r\n-// STEP 2 LOGIN: verify OTP, return token\r\n+// RESET PASSWORD\r\n // ---------------------------------------------------\r\n-eexport const verifyOtpLogin = async (req: Request, res: Response) => {\r\n+export const resetPassword = async (req: Request, res: Response) => {\r\n   try {\r\n-    const { email, otp } = req.body;\r\n+    const { email, password } = req.body;\r\n \r\n-    if (!email || !otp) {\r\n-      return res.status(400).json({ message: \"Email and OTP are required\" });\r\n-    }\r\n-\r\n     const user = await User.findOne({ email });\r\n-    if (!user) {\r\n-      return res.status(404).json({\r\n-        message: \"User not found. Please register first.\",\r\n-      });\r\n-    }\r\n+    if (!user) return res.status(404).json({ message: \"User not found\" });\r\n \r\n-    if (!user.otpHash || !user.otpExpiresAt) {\r\n-      return res.status(400).json({ message: \"OTP not requested or expired\" });\r\n-    }\r\n-\r\n-    if (user.otpExpiresAt.getTime() < Date.now()) {\r\n-      user.otpHash = null;\r\n-      user.otpExpiresAt = null;\r\n-      await user.save();\r\n-      return res.status(400).json({ message: \"OTP expired\" });\r\n-    }\r\n-\r\n-    const ok = await bcrypt.compare(otp, user.otpHash);\r\n-    if (!ok) return res.status(400).json({ message: \"Invalid OTP\" });\r\n-\r\n+    const hashed = await bcrypt.hash(password, 10);\r\n+    user.password = hashed;\r\n     user.otpHash = null;\r\n     user.otpExpiresAt = null;\r\n     await user.save();\r\n \r\n     const token = signToken(user._id.toString(), user.email);\r\n-    return res.json({ user, token });\r\n-  } catch (err) {\r\n-    console.error(\"Verify OTP error:\", err);\r\n+\r\n+    res.json({ user, token });\r\n+  } catch {\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n"
                }
            ],
            "date": 1761149501661,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\r\nimport bcrypt from 'bcrypt';\r\nimport jwt from 'jsonwebtoken';\r\nimport User, { IUser } from '../models/User';\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET!;\r\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\nconst SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n\r\nexport const register = async (req: Request, res: Response) => {\r\n  const { name, email, password } = req.body;\r\n  try {\r\n    // 1) Check if user already exists\r\n    const existing = await User.findOne({ email });\r\n    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n\r\n    // 2) Hash password\r\n    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n\r\n    // 3) Create user\r\n    const user = new User({ name, email, password: hashed });\r\n    await user.save();\r\n\r\n    // 4) Return safe user data (no password)\r\n    res.status(201).json({\r\n      message: 'User registered successfully',\r\n      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n    });\r\n  } catch (err: any) {\r\n    console.error(err);\r\n    res.status(500).json({ message: 'Server error' });\r\n  }\r\n};\r\n\r\nexport const login = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body;\r\n  try {\r\n    // 1) Find user\r\n    const user = await User.findOne({ email });\r\n    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n\r\n    // 2) Compare password\r\n    const match = await bcrypt.compare(password, user.password);\r\n    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n\r\n    // 3) Create JWT payload & token\r\n    const payload = { id: user._id, email: user.email, role: user.role };\r\n    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n\r\n    // 4) Return token and user info\r\n    res.json({\r\n      message: 'Login successful',\r\n      token,\r\n      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n    });\r\n  } catch (err: any) {\r\n    console.error(err);\r\n    res.status(500).json({ message: 'Server error' });\r\n  }\r\n};"
        }
    ]
}