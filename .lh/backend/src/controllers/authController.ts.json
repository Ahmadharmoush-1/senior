{
    "sourceFile": "backend/src/controllers/authController.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1761149501661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761149538869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,11 +27,12 @@\n     res.status(201).json({\r\n       message: 'User registered successfully',\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: any) {\r\n+  } catch (err: unknown) {\r\n     console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n   }\r\n };\r\n \r\n export const login = async (req: Request, res: Response) => {\r\n@@ -54,9 +55,10 @@\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: any) {\r\n+  } catch (err: unknown) {\r\n     console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n   }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761149615606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import { Request, Response } from 'express';\r\n+import type { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n import User, { IUser } from '../models/User';\r\n import dotenv from 'dotenv';\r\n"
                },
                {
                    "date": 1761149641009,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-import type { Request, Response } from 'express';\r\n+import { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n import User, { IUser } from '../models/User';\r\n import dotenv from 'dotenv';\r\n@@ -27,12 +27,11 @@\n     res.status(201).json({\r\n       message: 'User registered successfully',\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: unknown) {\r\n+  } catch (err: any) {\r\n     console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n+    res.status(500).json({ message: 'Server error' });\r\n   }\r\n };\r\n \r\n export const login = async (req: Request, res: Response) => {\r\n@@ -55,10 +54,9 @@\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n     });\r\n-  } catch (err: unknown) {\r\n+  } catch (err: any) {\r\n     console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n+    res.status(500).json({ message: 'Server error' });\r\n\\ No newline at end of file\n   }\r\n-};\n+};\r\n"
                },
                {
                    "date": 1761149646703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+import type { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User, { IUser } from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    // 1) Check if user already exists\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    // 2) Hash password\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+    // 3) Create user\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    // 4) Return safe user data (no password)\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    // 1) Find user\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 2) Compare password\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 3) Create JWT payload & token\r\n+    const payload = { id: user._id, email: user.email, role: user.role };\r\n+    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+    // 4) Return token and user info\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761149687697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n     res.json({\r\n       message: 'Login successful',\r\n       token,\r\n       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n+    }); \r\n   } catch (err: unknown) {\r\n     console.error(err);\r\n     const message = err instanceof Error ? err.message : 'Server error';\r\n     res.status(500).json({ message });\r\n"
                },
                {
                    "date": 1761150806864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+// import type { Request, Response } from 'express';\r\n+// import bcrypt from 'bcrypt';\r\n+// import jwt from 'jsonwebtoken';\r\n+// import User, { IUser } from '../models/User';\r\n+// import dotenv from 'dotenv';\r\n+// dotenv.config();\r\n+\r\n+// const JWT_SECRET = process.env.JWT_SECRET!;\r\n+// const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+// const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+// export const register = async (req: Request, res: Response) => {\r\n+//   const { name, email, password } = req.body;\r\n+//   try {\r\n+//     // 1) Check if user already exists\r\n+//     const existing = await User.findOne({ email });\r\n+//     if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+//     // 2) Hash password\r\n+//     const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+//     // 3) Create user\r\n+//     const user = new User({ name, email, password: hashed });\r\n+//     await user.save();\r\n+\r\n+//     // 4) Return safe user data (no password)\r\n+//     res.status(201).json({\r\n+//       message: 'User registered successfully',\r\n+//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+//     });\r\n+//   } catch (err: unknown) {\r\n+//     console.error(err);\r\n+//     const message = err instanceof Error ? err.message : 'Server error';\r\n+//     res.status(500).json({ message });\r\n+//   }\r\n+// };\r\n+\r\n+// export const login = async (req: Request, res: Response) => {\r\n+//   const { email, password } = req.body;\r\n+//   try {\r\n+//     // 1) Find user\r\n+//     const user = await User.findOne({ email });\r\n+//     if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+//     // 2) Compare password\r\n+//     const match = await bcrypt.compare(password, user.password);\r\n+//     if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+//     // 3) Create JWT payload & token\r\n+//     const payload = { id: user._id, email: user.email, role: user.role };\r\n+//     const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+//     // 4) Return token and user info\r\n+//     res.json({\r\n+//       message: 'Login successful',\r\n+//       token,\r\n+//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+//     }); \r\n+//   } catch (err: unknown) {\r\n+//     console.error(err);\r\n+//     const message = err instanceof Error ? err.message : 'Server error';\r\n+//     res.status(500).json({ message });\r\n+//   }\r\n+// };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150931079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+import type { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User, { IUser } from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    // 1) Check if user already exists\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    // 2) Hash password\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+\r\n+    // 3) Create user\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    // 4) Return safe user data (no password)\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    });\r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    // 1) Find user\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 2) Compare password\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    // 3) Create JWT payload & token\r\n+    const payload = { id: user._id, email: user.email, role: user.role };\r\n+    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+    // 4) Return token and user info\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n+    }); \r\n+  } catch (err: unknown) {\r\n+    console.error(err);\r\n+    const message = err instanceof Error ? err.message : 'Server error';\r\n+    res.status(500).json({ message });\r\n+  }\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150957446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n import type { Request, Response } from 'express';\r\n import bcrypt from 'bcrypt';\r\n import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n+import User, { IUser } from '../models/User.js';\r\n import dotenv from 'dotenv';\r\n dotenv.config();\r\n \r\n const JWT_SECRET = process.env.JWT_SECRET!;\r\n@@ -60,195 +60,5 @@\n     console.error(err);\r\n     const message = err instanceof Error ? err.message : 'Server error';\r\n     res.status(500).json({ message });\r\n   }\r\n-};\n-// import type { Request, Response } from 'express';\r\n-// import bcrypt from 'bcrypt';\r\n-// import jwt from 'jsonwebtoken';\r\n-// import User, { IUser } from '../models/User';\r\n-// import dotenv from 'dotenv';\r\n-// dotenv.config();\r\n-\r\n-// const JWT_SECRET = process.env.JWT_SECRET!;\r\n-// const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-// const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-// export const register = async (req: Request, res: Response) => {\r\n-//   const { name, email, password } = req.body;\r\n-//   try {\r\n-//     // 1) Check if user already exists\r\n-//     const existing = await User.findOne({ email });\r\n-//     if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-//     // 2) Hash password\r\n-//     const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-//     // 3) Create user\r\n-//     const user = new User({ name, email, password: hashed });\r\n-//     await user.save();\r\n-\r\n-//     // 4) Return safe user data (no password)\r\n-//     res.status(201).json({\r\n-//       message: 'User registered successfully',\r\n-//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-//     });\r\n-//   } catch (err: unknown) {\r\n-//     console.error(err);\r\n-//     const message = err instanceof Error ? err.message : 'Server error';\r\n-//     res.status(500).json({ message });\r\n-//   }\r\n-// };\r\n-\r\n-// export const login = async (req: Request, res: Response) => {\r\n-//   const { email, password } = req.body;\r\n-//   try {\r\n-//     // 1) Find user\r\n-//     const user = await User.findOne({ email });\r\n-//     if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-//     // 2) Compare password\r\n-//     const match = await bcrypt.compare(password, user.password);\r\n-//     if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-//     // 3) Create JWT payload & token\r\n-//     const payload = { id: user._id, email: user.email, role: user.role };\r\n-//     const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-//     // 4) Return token and user info\r\n-//     res.json({\r\n-//       message: 'Login successful',\r\n-//       token,\r\n-//       user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-//     }); \r\n-//   } catch (err: unknown) {\r\n-//     console.error(err);\r\n-//     const message = err instanceof Error ? err.message : 'Server error';\r\n-//     res.status(500).json({ message });\r\n-//   }\r\n-// };\n-import type { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    }); \r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\n-import { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: any) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: any) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n-  }\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761150968436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+import { Request, Response } from 'express';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import User from '../models/User';\r\n+import dotenv from 'dotenv';\r\n+dotenv.config();\r\n+\r\n+const JWT_SECRET = process.env.JWT_SECRET!;\r\n+const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+\r\n+export const register = async (req: Request, res: Response) => {\r\n+  const { name, email, password } = req.body;\r\n+  try {\r\n+    const existing = await User.findOne({ email });\r\n+    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+\r\n+    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n+    const user = new User({ name, email, password: hashed });\r\n+    await user.save();\r\n+\r\n+    res.status(201).json({\r\n+      message: 'User registered successfully',\r\n+      user: { id: user._id, name: user.name, email: user.email }\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Server error' });\r\n+  }\r\n+};\r\n+\r\n+export const login = async (req: Request, res: Response) => {\r\n+  const { email, password } = req.body;\r\n+  try {\r\n+    const user = await User.findOne({ email });\r\n+    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    const match = await bcrypt.compare(password, user.password);\r\n+    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });\r\n+\r\n+    res.json({\r\n+      message: 'Login successful',\r\n+      token,\r\n+      user: { id: user._id, name: user.name, email: user.email }\r\n+    });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Server error' });\r\n+  }\r\n+};\r\n"
                },
                {
                    "date": 1761151377660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,51 +1,46 @@\n-import { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User from '../models/User';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n+import { Request, Response } from \"express\";\r\n+import bcrypt from \"bcryptjs\";\r\n+import jwt from \"jsonwebtoken\";\r\n+import { User } from \"../models/User\";\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n+const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n \r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n+// Register\r\n+export const registerUser = async (req: Request, res: Response) => {\r\n   try {\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n+    const { name, email, password } = req.body;\r\n \r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n+    const existingUser = await User.findOne({ email });\r\n+    if (existingUser)\r\n+      return res.status(400).json({ message: \"User already exists\" });\r\n \r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email }\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    const hashedPassword = await bcrypt.hash(password, 10);\r\n+    const newUser = new User({ name, email, password: hashedPassword });\r\n+    await newUser.save();\r\n+\r\n+    res.status(201).json({ message: \"User registered successfully\" });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n \r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n+// Login\r\n+export const loginUser = async (req: Request, res: Response) => {\r\n   try {\r\n+    const { email, password } = req.body;\r\n+\r\n     const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n+    if (!user)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n+    if (!isPasswordValid)\r\n+      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const token = jwt.sign({ id: user._id, email: user.email }, JWT_SECRET, { expiresIn: '7d' });\r\n+    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n \r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email }\r\n-    });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Server error' });\r\n+    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+  } catch (error) {\r\n+    res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1761152279929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcryptjs\";\r\n+import bcrypt from \"bcrypt\";\r\n import jwt from \"jsonwebtoken\";\r\n import { User } from \"../models/User\";\r\n \r\n const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n@@ -43,68 +43,4 @@\n   } catch (error) {\r\n     res.status(500).json({ message: \"Server error\" });\r\n   }\r\n };\r\n-import type { Request, Response } from 'express';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import User, { IUser } from '../models/User.js';\r\n-import dotenv from 'dotenv';\r\n-dotenv.config();\r\n-\r\n-const JWT_SECRET = process.env.JWT_SECRET!;\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-const SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n-\r\n-export const register = async (req: Request, res: Response) => {\r\n-  const { name, email, password } = req.body;\r\n-  try {\r\n-    // 1) Check if user already exists\r\n-    const existing = await User.findOne({ email });\r\n-    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n-\r\n-    // 2) Hash password\r\n-    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n-\r\n-    // 3) Create user\r\n-    const user = new User({ name, email, password: hashed });\r\n-    await user.save();\r\n-\r\n-    // 4) Return safe user data (no password)\r\n-    res.status(201).json({\r\n-      message: 'User registered successfully',\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    });\r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-  const { email, password } = req.body;\r\n-  try {\r\n-    // 1) Find user\r\n-    const user = await User.findOne({ email });\r\n-    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 2) Compare password\r\n-    const match = await bcrypt.compare(password, user.password);\r\n-    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-    // 3) Create JWT payload & token\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-    // 4) Return token and user info\r\n-    res.json({\r\n-      message: 'Login successful',\r\n-      token,\r\n-      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n-    }); \r\n-  } catch (err: unknown) {\r\n-    console.error(err);\r\n-    const message = err instanceof Error ? err.message : 'Server error';\r\n-    res.status(500).json({ message });\r\n-  }\r\n-};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761390933070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,16 @@\n+// src/routes/authRoutes.ts\r\n+import express from \"express\";\r\n+import { registerUser, loginUser } from \"../controllers/authController\";\r\n+\r\n+const router = express.Router();\r\n+\r\n+// Test route (optional)\r\n+router.get(\"/test\", (_req, res) => {\r\n+  res.json({ ok: true, route: \"/api/auth/test\" });\r\n+});\r\n+\r\n+// Register & Login routes (using controllers)\r\n+router.post(\"/register\", registerUser);\r\n+router.post(\"/login\", loginUser);\r\n+\r\n+export default router;\r\n"
                },
                {
                    "date": 1762376236506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,62 +1,79 @@\n-// src/routes/authRoutes.ts\r\n-import express from \"express\";\r\n-import { registerUser, loginUser } from \"../controllers/authController\";\r\n+import { Request, Response } from 'express';\r\n+import User from '../models/User';\r\n+import bcrypt from 'bcrypt';\r\n+import jwt from 'jsonwebtoken';\r\n+import dotenv from 'dotenv';\r\n+import { isValidEmail } from '../utils/validate';\r\n \r\n-const router = express.Router();\r\n \r\n-// Test route (optional)\r\n-router.get(\"/test\", (_req, res) => {\r\n-  res.json({ ok: true, route: \"/api/auth/test\" });\r\n-});\r\n+dotenv.config();\r\n+const JWT_SECRET = process.env.JWT_SECRET || 'secret';\r\n+const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n \r\n-// Register & Login routes (using controllers)\r\n-router.post(\"/register\", registerUser);\r\n-router.post(\"/login\", loginUser);\r\n \r\n-export default router;\r\n-import { Request, Response } from \"express\";\r\n-import bcrypt from \"bcrypt\";\r\n-import jwt from \"jsonwebtoken\";\r\n-import { User } from \"../models/User\";\r\n+export const signup = async (req: Request, res: Response) => {\r\n+try {\r\n+const { name, email, password } = req.body;\r\n+if (!name || !email || !password) return res.status(400).json({ message: 'All fields required' });\r\n+if (!isValidEmail(email)) return res.status(400).json({ message: 'Invalid email' });\r\n \r\n-const JWT_SECRET = process.env.JWT_SECRET || \"secret123\";\r\n \r\n-// Register\r\n-export const registerUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { name, email, password } = req.body;\r\n+const existing = await User.findOne({ email });\r\n+if (existing) return res.status(409).json({ message: 'Email already in use' });\r\n \r\n-    const existingUser = await User.findOne({ email });\r\n-    if (existingUser)\r\n-      return res.status(400).json({ message: \"User already exists\" });\r\n \r\n-    const hashedPassword = await bcrypt.hash(password, 10);\r\n-    const newUser = new User({ name, email, password: hashedPassword });\r\n-    await newUser.save();\r\n+const salt = await bcrypt.genSalt(10);\r\n+const hashed = await bcrypt.hash(password, salt);\r\n \r\n-    res.status(201).json({ message: \"User registered successfully\" });\r\n-  } catch (error) {\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+\r\n+const user = await User.create({ name, email, password: hashed });\r\n+\r\n+\r\n+const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+\r\n+res.status(201).json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n };\r\n \r\n-// Login\r\n-export const loginUser = async (req: Request, res: Response) => {\r\n-  try {\r\n-    const { email, password } = req.body;\r\n \r\n-    const user = await User.findOne({ email });\r\n-    if (!user)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n+export const login = async (req: Request, res: Response) => {\r\n+try {\r\n+const { email, password } = req.body;\r\n+if (!email || !password) return res.status(400).json({ message: 'All fields required' });\r\n \r\n-    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n-    if (!isPasswordValid)\r\n-      return res.status(400).json({ message: \"Invalid email or password\" });\r\n \r\n-    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: \"1d\" });\r\n+const user = await User.findOne({ email });\r\n+if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n \r\n-    res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-  } catch (error) {\r\n-    res.status(500).json({ message: \"Server error\" });\r\n-  }\r\n+\r\n+const match = await bcrypt.compare(password, user.password);\r\n+if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n+\r\n+\r\n+const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n+\r\n+\r\n+res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n };\r\n+\r\n+\r\n+export const me = async (req: Request, res: Response) => {\r\n+try {\r\n+// @ts-ignore\r\n+const userId = req.userId;\r\n+const user = await User.findById(userId).select('-password');\r\n+if (!user) return res.status(404).json({ message: 'User not found' });\r\n+res.json({ user });\r\n+} catch (err) {\r\n+console.error(err);\r\n+res.status(500).json({ message: 'Server error' });\r\n+}\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762376244659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,79 +0,0 @@\n-import { Request, Response } from 'express';\r\n-import User from '../models/User';\r\n-import bcrypt from 'bcrypt';\r\n-import jwt from 'jsonwebtoken';\r\n-import dotenv from 'dotenv';\r\n-import { isValidEmail } from '../utils/validate';\r\n-\r\n-\r\n-dotenv.config();\r\n-const JWT_SECRET = process.env.JWT_SECRET || 'secret';\r\n-const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\n-\r\n-\r\n-export const signup = async (req: Request, res: Response) => {\r\n-try {\r\n-const { name, email, password } = req.body;\r\n-if (!name || !email || !password) return res.status(400).json({ message: 'All fields required' });\r\n-if (!isValidEmail(email)) return res.status(400).json({ message: 'Invalid email' });\r\n-\r\n-\r\n-const existing = await User.findOne({ email });\r\n-if (existing) return res.status(409).json({ message: 'Email already in use' });\r\n-\r\n-\r\n-const salt = await bcrypt.genSalt(10);\r\n-const hashed = await bcrypt.hash(password, salt);\r\n-\r\n-\r\n-const user = await User.create({ name, email, password: hashed });\r\n-\r\n-\r\n-const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-\r\n-res.status(201).json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\r\n-\r\n-\r\n-export const login = async (req: Request, res: Response) => {\r\n-try {\r\n-const { email, password } = req.body;\r\n-if (!email || !password) return res.status(400).json({ message: 'All fields required' });\r\n-\r\n-\r\n-const user = await User.findOne({ email });\r\n-if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-\r\n-const match = await bcrypt.compare(password, user.password);\r\n-if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n-\r\n-\r\n-const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n-\r\n-\r\n-res.json({ token, user: { id: user._id, name: user.name, email: user.email } });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\r\n-\r\n-\r\n-export const me = async (req: Request, res: Response) => {\r\n-try {\r\n-// @ts-ignore\r\n-const userId = req.userId;\r\n-const user = await User.findById(userId).select('-password');\r\n-if (!user) return res.status(404).json({ message: 'User not found' });\r\n-res.json({ user });\r\n-} catch (err) {\r\n-console.error(err);\r\n-res.status(500).json({ message: 'Server error' });\r\n-}\r\n-};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1761149501661,
            "name": "Commit-0",
            "content": "import { Request, Response } from 'express';\r\nimport bcrypt from 'bcrypt';\r\nimport jwt from 'jsonwebtoken';\r\nimport User, { IUser } from '../models/User';\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET!;\r\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\r\nconst SALT_ROUNDS = Number(process.env.BCRYPT_SALT_ROUNDS || 10);\r\n\r\nexport const register = async (req: Request, res: Response) => {\r\n  const { name, email, password } = req.body;\r\n  try {\r\n    // 1) Check if user already exists\r\n    const existing = await User.findOne({ email });\r\n    if (existing) return res.status(409).json({ message: 'Email already registered' });\r\n\r\n    // 2) Hash password\r\n    const hashed = await bcrypt.hash(password, SALT_ROUNDS);\r\n\r\n    // 3) Create user\r\n    const user = new User({ name, email, password: hashed });\r\n    await user.save();\r\n\r\n    // 4) Return safe user data (no password)\r\n    res.status(201).json({\r\n      message: 'User registered successfully',\r\n      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n    });\r\n  } catch (err: any) {\r\n    console.error(err);\r\n    res.status(500).json({ message: 'Server error' });\r\n  }\r\n};\r\n\r\nexport const login = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body;\r\n  try {\r\n    // 1) Find user\r\n    const user = await User.findOne({ email });\r\n    if (!user) return res.status(401).json({ message: 'Invalid credentials' });\r\n\r\n    // 2) Compare password\r\n    const match = await bcrypt.compare(password, user.password);\r\n    if (!match) return res.status(401).json({ message: 'Invalid credentials' });\r\n\r\n    // 3) Create JWT payload & token\r\n    const payload = { id: user._id, email: user.email, role: user.role };\r\n    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n\r\n    // 4) Return token and user info\r\n    res.json({\r\n      message: 'Login successful',\r\n      token,\r\n      user: { id: user._id, name: user.name, email: user.email, role: user.role }\r\n    });\r\n  } catch (err: any) {\r\n    console.error(err);\r\n    res.status(500).json({ message: 'Server error' });\r\n  }\r\n};"
        }
    ]
}